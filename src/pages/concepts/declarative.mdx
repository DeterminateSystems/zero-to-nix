---
title: Declarative
snippet: Fill me in later so that I show up in the tooltip
related: ["reproducibility"]
externalSources:
  [
    {
      title: "Declarative programming",
      href: "https://en.wikipedia.org/wiki/Declarative_programming",
      source: {
        title: "Wikipedia",
        href: "https://wikipedia.org"
      }
    },
    {
      title: "Declarative vs. imperative programming",
      href: "https://dev.to/ruizb/declarative-vs-imperative-4a7l",
      source: {
        title: "Benoit Ruiz's blog",
        href: "https://dev.to/ruizb"
      }
    },
    {
      title: "Declarative vs imperative programming: 5 key differences",
      href: "https://educative.io/blog/declarative-vs-imperative-programming",
      source: {
        title: "educative",
        href: "https://educative.io/"
      }
    }
  ]
---

In *declarative programming* a user instructs the computer in *what* to do, not on *how* to do it.

The result of this is that often a final system is described as it *should exist*.
A management program (in this case Nix) can then construct a path towards the final output
and do the necessary steps in the required order, without a user having to worry about what exactly is happening and when.

Nix follows declarative principles in the way that package definitions (or [derivations](/concepts/derivations)) are constructed with some minor exceptions.

Under the hood, some parts of packages still have to be written imperatively, but by wrapping these parts in declarative layers,
users of the upper layers don't have to be aware of what is happening below the surface.

Essentially: one user can solve a problem *once*,
and many people can then benefit from that solution without needing to know how exactly it works (unless they want to).
